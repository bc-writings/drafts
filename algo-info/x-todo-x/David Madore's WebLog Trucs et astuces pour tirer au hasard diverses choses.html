<!DOCTYPE html>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><!-- This file is automatically generated.  Do not edit! --><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<link href="http://www.madore.org/~david/favicon.ico" rel="Shortcut Icon">
<meta content="summary" name="twitter:card">
<meta content="@gro_tsen" name="twitter:site">
<meta content="Trucs et astuces pour tirer au hasard diverses choses" name="twitter:title">
<title>David Madore's WebLog: Trucs et astuces pour tirer au hasard diverses choses</title>
<meta content="David Alexander Madore's WebLog / Diary" name="Description">
<meta content="David Alexander Madore, WebLog, diary" name="Keywords">
<link href="http://www.madore.org/~david/weblog/weblog.rss" rel="alternate" title="RSS" type="application/rss+xml">
<style type="text/css">
/* <![CDATA[ */
body {
  color: black;
  font-family: Optima, "Zapf Humanist", Palatino, "Palatino Linotype", serif;
}
h1,h2,h3,h4,h5,h6 {
  font-family: Futura, "Century Gothic", "Avant Garde", "Avant Garde Gothic", Helvetica, Arial, sans-serif;
}
h1 { color: rgb(0,128,0); }
h2 { color: rgb(96,96,0); }
h3 { color: rgb(96,64,0); }
.title { text-align: center; }
.subtitle {
  font-size: 1.5em; text-align: center;
  font-family: Futura, "Century Gothic", "Avant Garde", "Avant Garde Gothic", Helvetica, Arial, sans-serif;
  color: rgb(24,96,0);
}
article { display: block; }
.navbar {
  display: block;
  font-size: .83em;
  font-family: "Times Roman", Times, "Times New Roman", serif;
}
.ffii-call {
  clear: both;
  color: red;
  font-size: 1.7em;
  font-family: Helvetica, Arial, sans-serif;
  text-align: center;
  border: outset;
}
.important { font-weight: bold; border: solid; padding: 1em; }
.outset { border: outset; padding-left: 0.5em; padding-right: 0.5em; }
.sidenote { font-size: .83em; }
.weblog-entry-headlink { color: rgb(128,64,0); }
.weblog-entry-headlink > a { color: inherit; }
.weblog-entry-title {
  color: black;
  font-size: 1.17em;
  font-weight: bold;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
}
.talkback-link {
  color: rgb(128,64,0); font-size: 0.83em; text-align: right;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
  margin-bottom: 0pt;
}
.talkback-link > a { color: inherit; }
.categories-list {
  color: rgb(128,64,0); font-size: 0.83em; text-align: right;
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
  margin-bottom: 0pt;
}
.categories-list > a { color: inherit; }
.cut-link {
  font-family: Futura, "Avant Garde", Helvetica, Arial, sans-serif;
}
.sitemap-note {
  font-style: italic;
  color: rgb(96,0,0);
}
.idlist > dt { color: rgb(96,64,0); }
.numtable td { text-align: right; }
.noparskip p { margin-top: 0; margin-bottom: 0; }
.cleared { clear: both; }
.cleared-left { clear: left; }
.cleared-right { clear: right; }
.pic { float: left; margin-right: 1em; margin-bottom: 1em; }
.pic-right { float: right; margin-left: 1em; margin-bottom: 1em; }
.pic-embed { float: left; margin-right: 1em; margin-bottom: 1em; margin-top: 1em; }
.pic-embed-right { float: right; margin-left: 1em; margin-bottom: 1em; margin-top: 1em; }
.max40 { max-width: 40%; height: auto; }
.max60 { max-width: 60%; height: auto; }
.max100 { max-width: 100%; height: auto; }
.smiley { vertical-align: middle; }
.centered { text-align: center; }
.separated { margin-top: 2.33em; }
.unicode-name { font-family: sans-serif; font-size: .83em; }
a { text-decoration: none; }
:lang(en) > q { quotes: "\201C" "\201D" "\2018" "\2019"; }
:lang(fr) > q { quotes: "\AB\A0" "\A0\BB" "\201C" "\201D"; }
:lang(de) > q { quotes: "\201E" "\201C" "\201A" "\2018"; }
q:before { content: open-quote; }
q:after { content: close-quote; }
li { -moz-float-edge: content-box; } /* Undo Mozilla buggy bugware! */
/* For despammed email addresses */
@media all { /* Hide from various buggy browsers! */
  .replace-commercial-at:before { content: "@"; }
  .replace-commercial-at > img { display: none; }
  .replace-full-stop:before { content: "."; }
  .replace-full-stop > img { display: none; }
  .replace-plus-sign:before { content: "+"; }
  .replace-plus-sign > img { display: none; }
}
/* Screen-specific rules */
@media screen {
  body { background: rgb(192,208,224); }
  .navbar {
    background: rgb(224,192,192);
    border: solid; border-color: rgb(224,0,0);
    padding: 1em;
    float: right; margin-left: 1.33em;
  }
  .important {
    background: rgb(208,208,208);
    border-color: rgb(255,0,0);
  }
  .weblog-entry {
    background: rgb(224,224,192);
    border: solid; border-color: rgb(128,64,0);
    padding: 1em; margin-bottom: 1em;
    overflow: hidden;
  }
  .outset { background: rgb(192,224,208); }
  .ffii-call { background: rgb(192,224,208); }
  :link { color: rgb(0,0,192); }
  :visited { color: rgb(96,0,192); }
  .weblog-internal-link:link,.weblog-internal-link:visited { color: rgb(0,64,192); }
  :link:hover,:visited:hover { text-decoration: underline; }
}
@media (max-width: 640px) {
  body { font-size: 12px; }
  .weblog-entry { padding: .5em; }
  .pic { margin-right: .5em; margin-bottom: .5em; }
  .pic-right { margin-left: .5em; margin-bottom: .5em; }
  .pic-embed { margin-right: .5em; margin-bottom: .5em; margin-top: .5em; }
  .pic-embed-right { margin-left: .5em; margin-bottom: .5em; margin-top: .5em; }
}
@media (min-width: 641px) and (max-width: 780px) {
  body { font-size: 14px; }
}
@media (min-width: 781px) {
  body { font-size: 16px; }
}
@media print {
  .navbar { display: none; }
}
/* ]]> */
</style>
<script type="text/javascript">
// <![CDATA[
"use strict";

var textNodeType;

function textContent(n) {
    if ( n.nodeType == textNodeType ) {
	return n.data;
    } else {
	var children = n.childNodes;
	var t = "";
	for ( var i=0 ; i<children.length ; i++ ) {
	    t = t.concat(textContent(children.item(i)));
	}
	return t;
    }
}

function despam() {
    // MSIE seems to barf...  Deactivate for now
    if ( (/MSIE *[1-6]\./).test(navigator.userAgent) )
	return;
    // Now replace as appropriate.
    var elts = document.getElementsByTagName("span");
    for ( var i=0 ; i<elts.length ; i++ ) {
	var elt = elts.item(i);
	if ( elt.className == "replace-commercial-at" ) {
	    elt.parentNode.replaceChild(document.createTextNode("@"),elt);
	    i--;  // Semi-bugware
	} else if ( elt.className == "replace-full-stop" ) {
	    elt.parentNode.replaceChild(document.createTextNode("."),elt);
	    i--;  // Semi-bugware
	} else if ( elt.className == "replace-plus-sign" ) {
	    elt.parentNode.replaceChild(document.createTextNode("+"),elt);
	    i--;  // Semi-bugware
	}
    }
    // Merge adjacent text nodes.
    try {
	document.normalize();  // Your DOM is BROKEN!
    } catch (exn) {
	document.documentElement.normalize();
    }
    // Next, process all <a> elements having class="despammed-address".
    elts = document.getElementsByTagName("a");
    for ( var i=0 ; i<elts.length ; i++ ) {
	var elt = elts.item(i);
	if ( elt.className == "despammed-address" ) {
	    var addr = "mailto:".concat(textContent(elt));
	    elt.setAttribute("href",addr);  // (abstract)
	    elt.href = addr;  // (semantic)
	}
    }
}

function permuteWord(s) {
    if ( s.length <= 3 )
	return s;
    var tab = s.split("");
    var n = tab.length - 1;
    for ( var i=1 ; i<n ; i++ ) {
	var j = i + Math.floor(Math.random()*(n-i));
	if ( j == i )
	    continue;
	var tmp = tab[j];
	tab[j] = tab[i];
	tab[i] = tmp;
    }
    return tab.join("");
}

function permuteString(s) {
    return s.replace(/[A-Za-zÀ-ÿ]+/g, permuteWord);
}

function permuteDoc(doc) {
    var body = doc.body;
    var walker = doc.createTreeWalker(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
    var node = walker.nextNode();
    while ( node ) {
	if ( node.nodeType == Node.TEXT_NODE ) {
	    var thisnode = node;
	    node = walker.nextNode();
	    var str = permuteString(thisnode.nodeValue);
	    thisnode.parentNode.replaceChild(doc.createTextNode(str), thisnode);
	} else if ( node.nodeType == Node.ELEMENT_NODE
		    && ( node.localName == "pre"
			 || node.localName == "code"
			 || node.localName == "script"
			 || node.localName == "style" ) ) {
	    do {
		node = walker.nextSibling();
		if ( node )
		    break;
		node = walker.parentNode();
		if ( ! node )
		    break;
	    } while ( true );
	} else
	    node = walker.nextNode();
    }
}

function onLoad() {
    // Start with some bugware...
    try {
	textNodeType = Node.TEXT_NODE;
    } catch (exn) {  // Your DOM is BROKEN!
	textNodeType = 3;
    }
    // Now despam email adresses.
    despam();
}
// ]]>
</script>
</head>
<body onload="onLoad()" data-new-gr-c-s-check-loaded="8.876.0" data-gr-ext-installed="">
<header>
<hgroup>
<h1 class="title">David Madore's WebLog: <span xml:lang="fr" lang="fr">Trucs et astuces pour tirer au hasard diverses choses</span></h1>
</hgroup>
<nav class="navbar"><a href="http://www.madore.org/~david/">David Madore</a><br><a href="http://perso.enst.fr/madore/">Prof. site</a><br><a href="http://www.madore.org/~david/">Site Root</a><br><a href="http://www.madore.org/~david/sitemap.html">Site Map</a><br><a href="http://www.madore.org/~david/weblog/">WebLog</a></nav>
</header>

<p class="sidenote">[<a href="http://www.madore.org/~david/weblog/weblog-index.html#index">Index of all
entries / <span xml:lang="fr" lang="fr">Index de toutes les entrées</span></a>
• <a href="http://www.madore.org/~david/weblog/">Latest entries / <span xml:lang="fr" lang="fr">Dernières
entrées</span></a> • <a href="http://www.madore.org/~david/weblog/weblog.rss" rel="alternate" title="RSS" type="application/rss+xml"><img alt="XML" src="David%20Madore's%20WebLog%20Trucs%20et%20astuces%20pour%20tirer%20au%20hasard%20diverses%20choses_fichiers/xml.gif" width="36" height="14"></a> (<abbr>RSS</abbr>&nbsp;1.0)
• <a href="http://www.madore.org/cgi-bin/comment.pl/lscomments">Recent
comments / <span xml:lang="fr" lang="fr">Commentaires récents</span></a>]</p>

<div class="cleared-right"><!-- EMPTY --></div>

<div><p><span>↓Entry #2686 [<a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-05-21.2685.points-and-lines.html#d.2021-05-21.2685" title="Configurations de points et droites&nbsp;: un petit projet mathématico-physico-artistique">older</a>|<a class="weblog-internal-link" href="#d.2021-06-02.2686" style="opacity: 0.1" title="Trucs et astuces pour tirer au hasard diverses choses">※</a> <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-06-02.2686.random-generation.html#d.2021-06-02.2686" title="Trucs et astuces pour tirer au hasard diverses choses">permalink</a>|<del>newer</del>]</span> / <span xml:lang="fr" lang="fr">↓Entrée #2686 [<a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-05-21.2685.points-and-lines.html#d.2021-05-21.2685" title="Configurations de points et droites&nbsp;: un petit projet mathématico-physico-artistique">précédente</a>|<a class="weblog-internal-link" href="#d.2021-06-02.2686" style="opacity: 0.1" title="Trucs et astuces pour tirer au hasard diverses choses">※</a> <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-06-02.2686.random-generation.html#d.2021-06-02.2686" title="Trucs et astuces pour tirer au hasard diverses choses">permalien</a>|<del>suivante</del>]</span> ↓</p><article class="weblog-entry hentry" id="d.2021-06-02.2686" xml:lang="fr" lang="fr">
<header><p class="weblog-entry-headlink"><a href="http://www.madore.org/~david/weblog/d.2021-06-02.2686.random-generation.html#d.2021-06-02.2686" rel="bookmark"><time class="published" datetime="2021-06-02T23:22:12+02:00" pubdate="pubdate">2021-06-02</time></a> (mercredi)</p>
<h2 class="weblog-entry-title entry-title">Trucs et astuces pour tirer au hasard diverses choses</h2></header>
<div class="entry-content">

<p>Je rassemble dans cette entrée quelques faits algorithmiques et
informatiques qui sont généralement «&nbsp;bien connus&nbsp;» (et franchement
assez basiques) mais souvent utiles, et qu'il est possiblement
difficile de trouver rassemblés en un seul endroit.  Le problème
général est de tirer algorithmiquement des variables aléatoires selon
différentes distributions, typiquement à partir d'un générateur
aléatoire qui produit soit des bits aléatoires (indépendants et non
biaisés) soit des variables aléatoires réelles (indépendantes)
uniformément réparties sur&nbsp;[0;1].  Je parle d'algorithmique, mais ce
n'est pas uniquement sur un ordinateur&nbsp;: ça peut être utile même dans
la vie réelle, par exemple si on a une pièce avec laquelle on peut
tirer à pile ou face et qu'on veut s'en servir pour jouer à un jeu qui
réclame des dés à 6&nbsp;faces, ou si on a des dés à 6&nbsp;faces et qu'on veut
jouer à un jeu d'aventure qui réclame des dés à 20&nbsp;faces.</p>
<p><strong>Comment tirer des nombres aléatoires en conditions
adversariales&nbsp;?</strong> Je commence par ce problème-ci qui n'a pas de
rapport direct avec la suite, mais que je trouve quand même opportun
de regrouper avec&nbsp;: Alice et Bob veulent jouer à pile ou face, ou plus
généralement tirer un dé à <var>n</var> faces, mais ils n'ont pas de
pièce ou de dé en lequel ils fassent tous les deux confiance.  Par
exemple, Alice a sa pièce fétiche que Bob soupçonne d'être truquée et
symétriquement (ou peut-être même que chacun est persuadé de pouvoir
tirer des nombres aléatoires dans sa tête mais ne fait évidemment pas
confiance à l'autre).  La solution est la suivante&nbsp;: chacun fait un
tirage avec son propre moyen de son côté, <em>sans connaître le
résultat de l'autre</em>, et on combine ensuite les résultats selon
n'importe quelle opération (choisie à l'avance&nbsp;!) qui donne tous
les <var>n</var> résultats possibles pour chaque valeur fixée d'une
quelconque des entrées
(un <a href="http://en.wikipedia.org/wiki/Latin_square">carré
latin</a>, par exemple une loi de groupe)&nbsp;; par exemple, s'il s'agit
de tirer à pile ou face, on peut décider (à l'avance&nbsp;!) que le
résultat sera <q>pile</q>&nbsp;(0) si les deux pièces ont donné le même
résultat et <q>face</q>&nbsp;(1) si elles ont donné un résultat différent&nbsp;;
s'il s'agit de dés à <var>n</var> faces donnant un résultat entre
0&nbsp;et&nbsp;<var>n</var>−1, on fait la somme modulo <var>n</var>
(c'est-à-dire qu'on fait la somme et qu'on soustrait <var>n</var> si
elle vaut au moins <var>n</var>, pour se ramener à un résultat entre
0&nbsp;et&nbsp;<var>n</var>−1).  Bien sûr, il faut un protocole pratique pour
faire en sorte que chacun fasse son tirage sans connaître le résultat
de l'autre (sinon, s'il a moyen de tricher, il pourra adapter le
résultat en conséquence)&nbsp;: physiquement, chacun peut faire son tirage
en secret et écrire le résultat secrètement sur un papier placé dans
une enveloppe scellée, qu'on ouvrira une fois les deux tirages
effectués (en fait, il n'y a que le premier tirage qui a besoin d'être
fait de la sorte)&nbsp;; cryptographiquement, on procède à
une <a href="http://en.wikipedia.org/wiki/Commitment_scheme">mise en
gage</a> (typiquement au moyen d'une fonction de hachage, mais je ne
veux pas entrer dans ces questions-là).  On peut bien sûr généraliser
à plus que deux joueurs (en faisant la somme modulo <var>n</var> de
nombres tirés par chacun des participants).  Le protocole garantit que
le résultat sera un tirage uniforme honnête si <em>l'un au moins</em>
des participants désire qu'il le soit (et a les moyens de réaliser un
tirage honnête)&nbsp;: bien sûr, si aucun des participants ne le souhaite,
c'est leur problème, donc on s'en fout.  Même si on abandonne toute
prétention à ce que les participants <em>tirent</em> leur valeur
aléatoirement et qu'on s'imagine qu'ils la <em>choisissent</em>, tant
qu'il s'agit d'un jeu à somme nulle, la stratégie optimale est bien de
tirer au hasard (et encore une fois, s'ils veulent coopérer pour un
autre résultat, tant qu'il n'y a pas d'autre partie impliquée, c'est
leur problème, de même s'ils s'imaginent pouvoir faire mieux que le
hasard en utilisant, par exemple, une prédiction psychologique).</p>
<p class="sidenote">Je ne sais plus où j'avais lu que ce protocole a
été découvert (il l'a certainement été de nombreuses fois&nbsp;!) à la
renaissance.  Dans mon souvenir, le découvreur proposait même que,
pour une question de la plus haute importance, on demande au pape de
faire un des tirages en plus de tous les autres participants.  Je ne
sais d'ailleurs pas si ce protocole a un nom standard.</p>
<p><strong>Comment tirer une variable de Bernoulli de
paramètre <var>p</var> à partir de bits aléatoires&nbsp;?</strong>
Autrement dit, ici, on a fixé <var>p</var>, et on veut faire un tirage
aléatoire qui renvoie <q>oui</q> avec probabilité&nbsp;<var>p</var>
et <q>non</q> avec probabilité 1−<var>p</var>, et pour ça, on dispose
simplement d'une pièce qui renvoie des bits aléatoires en tirant à
pile&nbsp;(0) ou face&nbsp;(1), et on souhaite effectuer les tirages de façon
économique.  Par exemple, combien de tirages de pièce faut-il, en
moyenne, pour générer un événement de probabilité&nbsp;1/3&nbsp;?  Il s'avère,
en fait, que quel que soit <var>p</var> on peut s'en tirer avec
deux&nbsp;(2) tirages en moyenne (je veux dire <q>en espérance</q>).  Pour
cela, on peut procéder ainsi&nbsp;: on effectue des tirages répétés et on
interprète les bits aléatoires ainsi produits comme l'écriture binaire
d'un nombre réel <var>x</var> uniformément réparti entre 0&nbsp;et&nbsp;1&nbsp;: on
compare <var>x</var> à 1−<var>p</var> en binaire, c'est-à-dire qu'on
s'arrête dès qu'on dispose d'assez de bits pour pouvoir décider
si <var>x</var>&nbsp;&lt;&nbsp;1−<var>p</var>
ou <var>x</var>&nbsp;&gt;&nbsp;1−<var>p</var> (on peut considérer le
cas <var>x</var>&nbsp;=&nbsp;1−<var>p</var> comme s'il était impossible vu qu'il
est de probabilité&nbsp;0), en notant qu'on va
avoir <var>x</var>&nbsp;&lt;&nbsp;1−<var>p</var> lorsque le <var>k</var>-ième
bit tiré est&nbsp;0 et que le <var>k</var>-ième bit de l'écriture binaire
de&nbsp;<var>p</var> vaut&nbsp;0, et <var>x</var>&nbsp;&gt;&nbsp;1−<var>p</var> lorsque
le <var>k</var>-ième bit tiré est&nbsp;1 et que le <var>k</var>-ième bit
de <var>p</var> vaut&nbsp;1&nbsp;; et si <var>x</var>&nbsp;&lt;&nbsp;1−<var>p</var> on
renvoie <q>oui</q>, sinon <q>non</q>.  Concrètement, donc, faire des
tirages aléatoires jusqu'à ce que le <var>k</var>-ième bit tiré soit
égal au <var>k</var>-ième bit de l'écriture de&nbsp;<var>p</var>, et alors
s'arrêter et renvoyer ce bit-là.  Il est clair que cet algorithme
fonctionne, mais pour qu'il soit encore plus évident qu'il conduit à
faire deux tirages en moyenne, on peut le reformuler de la façon
encore plus élégante suivante (il suffit d'échanger les résultats
0&nbsp;et&nbsp;1 pour <var>x</var>, qui sont complètement symétriques, lorsque
le bit correspondant de&nbsp;<var>p</var> vaut&nbsp;0)&nbsp;: <em>tirer des bits
aléatoires jusqu'à tomber sur&nbsp;1, et lorsque c'est le cas, s'arrêter et
renvoyer le <var>k</var>-ième bit de&nbsp;<var>p</var></em>
(où <var>k</var> est le nombre de bits aléatoires qui ont été tirés).
Je trouve ça incroyablement élégant et astucieux (même si c'est très
facile), et je ne sais pas d'où sort ce truc.  (Cela revient encore à
tirer une variable aléatoire <var>k</var> distribuée selon une loi
géométrique d'espérance&nbsp;1, comme je l'explique plus bas, c'est-à-dire
valant <var>k</var> avec probabilité (½)<sup><var>k</var>+1</sup>, et
renvoyer le (<var>k</var>+1)-ième
bit <var>b</var><sub><var>k</var>+1</sub> de&nbsp;<var>p</var>, ce qui,
quand on écrit <var>p</var> =
∑<sub><var>k</var>=0</sub><sup>+∞</sup>&nbsp;<var>b</var><sub><var>k</var>+1</sub>·(½)<sup><var>k</var>+1</sup>,
est finalement assez évident.)</p>
<p><strong>Comment tirer un entier aléatoire entre 0 et <var>n</var>−1
à partir de bits aléatoires&nbsp;?</strong>  (Ma première réaction en
entendant ce problème a été de dire&nbsp;: considérer <var>x</var> uniforme
dont l'écriture binaire est donnée par la suite des bits tirés,
générer suffisamment de bits pour calculer la valeur de
⌊<var>n</var>·<var>x</var>⌋, où ⌊—⌋ désigne la partie entière, et
renvoyer celle-ci.  Ceci fonctionne, mais ce n'est pas le plus
efficace.  Un autre algorithme avec rejet consiste à
générer <var>r</var> := ⌈log(<var>n</var>)/log(2)⌉ bits, qui, lus en
binaire, donnent un entier aléatoire <var>c</var> entre 0 et
2<sup><var>r</var></sup>−1, renvoyer <var>c</var> s'il
est&nbsp;&lt;<var>n</var>, et sinon tout recommencer.  Mais ce n'est pas
très efficace non plus, quoique dans des cas un peu différents.)  Je
décris ce problème plus en détails
dans <a href="https://twitter.com/gro_tsen/status/1386448258176884737">ce
fil Twitter</a>, mais donnons juste l'algorithme&nbsp;: on utilise deux
variables internes à l'algorithme, notées <var>v</var>
et <var>c</var>, qu'on initialise par <var>v</var>←1 et <var>c</var>←0
(il s'agit d'un <q>réservoir d'entropie</q>, et la garantie est
que <var>c</var> est aléatoire uniformément réparti entre
0&nbsp;et&nbsp;<var>v</var>−1)&nbsp;; puis on effectue une boucle&nbsp;: à chaque étape,
on génère un bit aléatoire <var>b</var> (valant 0&nbsp;ou&nbsp;1 avec
probabilité&nbsp;½ pour chacun, et indépendant de tous les autres, donc) et
on remplace <var>v</var>&nbsp;←&nbsp;2<var>v</var>
et <var>c</var>&nbsp;←&nbsp;2<var>c</var>+<var>b</var>&nbsp;; puis on
compare <var>v</var>&nbsp;avec&nbsp;<var>n</var>
et <var>c</var>&nbsp;avec&nbsp;<var>n</var>&nbsp;: si <var>v</var>&lt;<var>n</var>
(ce qui implique forcément <var>c</var>&lt;<var>n</var>) on continue
simplement la boucle (il n'y a pas assez d'entropie)&nbsp;;
si <var>v</var>≥<var>n</var> et <var>c</var>&lt;<var>n</var>, on
termine l'algorithme en renvoyant la valeur <var>c</var>&nbsp;; enfin,
si <var>c</var>≥<var>n</var>, on
effectue <var>v</var>&nbsp;←&nbsp;<var>v</var>−<var>n</var>
et <var>c</var>&nbsp;←&nbsp;<var>c</var>−<var>n</var> et on continue la boucle.
Le calcul du nombre moyen de tirages effectués est fastidieux
(voir <a href="http://arxiv.org/abs/1304.1916" title="Jérémie Lumbroso — Optimal Discrete Uniform Generation from Coin Flips, and Applications">cette référence</a> citée dans le fil Twitter référencée
ci-dessus), mais c'est optimal.</p>
<p>L'algorithme que je viens de décrire s'adapte assez bien pour tirer
un entier uniforme entre 0&nbsp;et&nbsp;<var>n</var>−1 à partir d'une source de
entiers uniformes entre 0&nbsp;et&nbsp;<var>m</var>−1 (le cas que je viens de
décrire est le cas <var>m</var>=2), autrement dit&nbsp;: <strong>comment
fabriquer un dé à <var>n</var> faces à partir d'un dé à <var>m</var>
faces&nbsp;?</strong>  Je n'ai pas vraiment envie de réfléchir à si c'est
optimal (<strong>mise à
jour</strong>&nbsp;: <a href="https://twitter.com/apyroman/status/1400460049554677762">on
l'a fait pour moi</a>), mais c'est en tout cas assez élégant&nbsp;: on
utilise deux variables internes à l'algorithme, notées <var>v</var>
et <var>c</var>, qu'on initialise par <var>v</var>←1
et <var>c</var>←0&nbsp;; puis on effectue une boucle&nbsp;: à chaque étape, on
génère un tirage aléatoire <var>b</var> entre 0&nbsp;et&nbsp;<var>m</var>−1 à
partir de la source dont on dispose et on
remplace <var>v</var>&nbsp;←&nbsp;<var>m</var>·<var>v</var>
et <var>c</var>&nbsp;←&nbsp;<var>m</var>·<var>c</var>+<var>b</var>&nbsp;; puis on
effectue la division euclidienne de <var>v</var> et de <var>c</var>
par&nbsp;<var>n</var>&nbsp;: si les deux quotients calculés sont différents
(⌊<var>c</var>/<var>n</var>⌋ &lt; ⌊<var>v</var>/<var>n</var>⌋), on
termine l'algorithme en renvoyant le reste <var>c</var>%<var>n</var>
:= <var>c</var> − <var>n</var>·⌊<var>c</var>/<var>n</var>⌋ de la
division de&nbsp;<var>c</var> par&nbsp;<var>n</var>, tandis que si les deux
quotients sont égaux, on remplace chacun par son reste,
c'est-à-dire <var>v</var>&nbsp;←&nbsp;<var>v</var>%<var>n</var>
et <var>c</var>&nbsp;←&nbsp;<var>c</var>%<var>n</var> et on continue la
boucle.</p>
<p>Introduisons maintenant aussi des tirages continus.</p>
<p><strong>Comment tirer uniformément un point dans le simplexe de
dimension&nbsp;<var>d</var>&nbsp;?</strong>  Autrement dit, on veut
obtenir <var>d</var>+1 réels positifs
(<var>z</var><sub>0</sub>,…,<var>z</var><sub><var>d</var></sub>) de
somme&nbsp;1 uniformément répartis sur toutes les possibilités&nbsp;: ce qui
revient à dire que disons, les <var>d</var> premiers sont uniformément
répartis sur toutes les possibilités, ce qui est cette fois un
conditionnement simple&nbsp;: il y a donc un algorithme trivial mais trop
inefficace qui consiste à
tirer <var>z</var><sub>0</sub>,…,<var>z</var><sub><var>d</var>−1</sub>
aléatoirement (indépendamment et uniformément) entre 0&nbsp;et&nbsp;1,
poser <var>z</var><sub><var>d</var></sub> := 1
−&nbsp;<var>z</var><sub>0</sub> −&nbsp;⋯
−&nbsp;<var>z</var><sub><var>d</var>−1</sub>, tester
si <var>z</var><sub><var>d</var></sub>≥0 et recommencer tous les
tirages si ce n'est pas le cas&nbsp;; ceci fonctionne, mais
demandera <var>d</var>! essais en moyenne, ce qui n'est pas
acceptable.</p>
<p>Voici un algorithme qui marche et qui est efficace&nbsp;:
tirer <var>d</var> nombres réels aléatoirement (indépendamment et
uniformément) entre 0&nbsp;et&nbsp;1, <em>trier</em> ces nombres en ordre
croissant, disons qu'on les
appelle <var>t</var><sub>1</sub>≤⋯≤<var>t</var><sub><var>d</var></sub>,
poser <var>t</var><sub>0</sub>=0
et <var>t</var><sub><var>d</var>+1</sub>=1, et
définir <var>z</var><sub><var>i</var></sub>
:= <var>t</var><sub><var>i</var>+1</sub>
− <var>t</var><sub><var>i</var></sub>.</p>
<p class="sidenote">En revanche, que je sache, si on veut tirer un
point
du <a href="http://en.wikipedia.org/wiki/Birkhoff_polytope">polytope
de Birkhoff</a>, c'est-à-dire une matrice carrée à coefficients
positifs dont toutes les lignes et toutes les colonnes ont somme&nbsp;1
(matrice <q>bistochastique</q>), il n'y a pas d'algorithme intelligent
connu (seulement des méthodes approchées).  Ceci illustre le fait que
ce n'est pas parce qu'un ensemble est facile à décrire qu'il est
facile de tirer au hasard uniformément dedans.</p>
<p>Une autre façon de tirer un point dans le simplexe (continu, i.e.,
réel) de dimension&nbsp;<var>d</var> consiste à tirer <var>d</var>+1 réels
positifs selon une loi <em>exponentielle</em> (cf.&nbsp;ci-dessous),
toujours la même, mais peu importe son paramètre, et ensuite les
diviser par leur somme (i.e., normaliser pour avoir une somme&nbsp;1).</p>
<p>Ayant parlé du simplexe continu, je ne peux pas ne pas évoquer le
simplexe discret et la question de <strong>comment tirer uniformément
un point dans le simplexe discret de dimension&nbsp;<var>d</var> et de
taille <var>N</var></strong>, autrement dit, <var>d</var>+1 entiers
positifs
(<var>a</var><sub>0</sub>,…,<var>a</var><sub><var>d</var></sub>) de
somme&nbsp;<var>N</var> uniformément répartis sur toutes les possibilités.
L'adaptation évidente de l'algorithme avec tri que j'ai donné ne
marche pas (il faudrait tirer <var>d</var> entiers entre
0&nbsp;et&nbsp;<var>N</var> non pas indépendamment avant de les trier, mais
selon une <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2009-01-31.1606.tirages-bosons-et-fermions.html#d.2009-01-31.1606" title="Comment tirer des bosons d'une urne&nbsp;?">urne de Pólya</a>&nbsp;; comme ce
n'est pas évident, le plus simple est de faire la chose suivante)&nbsp;: à
la place, on va plutôt tirer <var>d</var> entiers <em>distincts</em>
entre 1&nbsp;et&nbsp;<var>N</var>+<var>d</var> (il y a toutes sortes de manières
de faire ça, ce n'est pas compliqué et je ne rentre pas dans les
détails, le plus évident est simplement de tirer chaque nombre en
recommençant tant qu'on tombe sur un nombre déjà tiré), les trier
en <var>v</var><sub>1</sub>&lt;⋯&lt;<var>v</var><sub><var>d</var></sub>,
poser <var>v</var><sub>0</sub>=0
et <var>v</var><sub><var>d</var>+1</sub>=<var>N</var>+<var>d</var>+1,
et définir <var>a</var><sub><var>i</var></sub>
:= <var>v</var><sub><var>i</var>+1</sub>
−&nbsp;<var>v</var><sub><var>i</var></sub> −&nbsp;1.  Mais une façon différente
et possiblement intéressante dans certains cas d'obtenir ce tirage est
de commencer par tirer
(<var>z</var><sub>0</sub>,…,<var>z</var><sub><var>d</var></sub>) dans
le simplexe (réel) comme je viens de le dire, puis de simuler
une <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2009-06-09.1649.elections-proportionnelle.html#d.2009-06-09.1649" title="Comment faire une élection à la proportionnelle">élection à la proportionnelle</a> à
la plus forte moyenne avec la méthode d'Hondt (concrètement, cela
signifie qu'on commence avec
(<var>a</var><sub>0</sub>,…,<var>a</var><sub><var>d</var></sub>) ←
(0,…,0), puis on trouve le <var>i</var> qui
maximise <var>z</var><sub><var>i</var></sub>/(<var>a</var><sub><var>i</var></sub>+1),
et on l'incrémente, <var>a</var><sub><var>i</var></sub>
← <var>a</var><sub><var>i</var></sub>+1, et on répète ça <var>N</var>
fois&nbsp;; la preuve du fait que ceci donne bien une répartition uniforme
sur les
(<var>a</var><sub>0</sub>,…,<var>a</var><sub><var>d</var></sub>)
est <a href="https://groups.google.com/g/sci.math.research/c/UPzHEIDfeUo">donnée
ici</a>).  Bon, je ne sais pas dans quel cas cet algorithme bizarre
pourrait servir (peut-être si on ne connaît pas <var>N</var> à
l'avance&nbsp;?), mais il est tellement remarquable que je ne peux pas ne
pas le mentionner.</p>
<p><strong>Comment tirer un réel selon une loi
exponentielle&nbsp;?</strong>  Pour en avoir une d'espérance&nbsp;1, il suffit
de prendre l'opposé du logarithme (naturel) d'un réel aléatoire
uniforme entre 0&nbsp;et&nbsp;1.  (Ceci pose un problème de précision si le
nombre aléatoire uniforme est trop proche de&nbsp;0&nbsp;: je ne veux pas
rentrer dans ces questions-là, mais une façon de corriger est que si
le réel uniforme est, disons, &lt;1/<var>N</var> avec <var>N</var>
fixé à l'avance, par exemple une puissance de&nbsp;2, on le jette et on
tire un autre réel aléatoire uniforme qu'on divise ensuite
par&nbsp;<var>N</var>&nbsp;: et on fera bien sûr ça de façon récursive,
c'est-à-dire que la fonction <q>calculer un réel uniforme entre 0&nbsp;et&nbsp;1
à résolution améliorée proche de&nbsp;0</q> commence par tirer un réel
uniforme entre 0&nbsp;et&nbsp;1 avec une résolution standard, et s'il est
&lt;1/<var>N</var>, le jette, s'applique elle-même de façon récursive
et renvoie le résultat divisé par&nbsp;<var>N</var>&nbsp;: ceci peut évidemment
être rendu itératif de façon facile.)  Pour une loi exponentielle
d'espérance&nbsp;<var>a</var>, il suffit bien sûr simplement de multiplier
par&nbsp;<var>a</var>.</p>
<p><strong>Et pour un entier distribué selon une loi géométrique
(exponentielle discrète)&nbsp;?</strong>  Si <var>p</var> (la probabilité
de succès) n'est pas excessivement petit, le plus simple à programmer
est simplement l'algorithme naïf consistant à tirer des variables de
Bernoulli de paramètre <var>p</var> (indépendantes) de façon répétée
jusqu'à obtenir un succès, et renvoyer le nombre d'échecs&nbsp;; on peut
aussi, pour le même résultat, tirer un réel selon une loi
exponentielle d'espérance −1/log(1−<var>p</var>) et prendre sa partie
entière&nbsp;: ceci produit une variable de loi géométrique d'espérance
(1−<var>p</var>)/<var>p</var>.</p>
<p><strong>Comment tirer un entier distribué selon une loi de
Poisson&nbsp;?</strong>  Si l'espérance <var>λ</var> désirée n'est pas
excessivement grande, le plus simple à programmer est simplement
l'algorithme naïf consistant à simuler un processus de Poisson&nbsp;: tirer
des variables exponentielles d'espérance&nbsp;1 (indépendantes) de façon
répétée jusqu'à ce que leur somme dépasse <var>λ</var>, et renvoyer le
nombre de variables tirées moins&nbsp;1&nbsp;; d'après la manière dont j'ai
décrit la façon de tirer des variables aléatoires exponentielles, cela
revient aussi à tirer des variables aléatoires uniformes entre 0&nbsp;et&nbsp;1
(indépendantes) de façon répétée jusqu'à ce que leur produit passe
en-dessous de exp(−<var>λ</var>) (et toujours renvoyer le nombre de
variables tirées moins&nbsp;1).</p>
<p class="sidenote">Je rappelle qu'un processus de Poisson (homogène)
s'obtient de la façon suivante&nbsp;: partir de 0 et sommer de façon
répétée des variables exponentielles indépendantes (de même espérance,
l'inverse de la densité voulue) pour obtenir les valeurs positives du
processus, et faire la même chose avec un signe moins pour les
négatives, puis <em>oublier la valeur zéro</em> (ça ressemble à une
erreur, parce qu'on se dit qu'on crée un trou plus grand en zéro,
pourtant c'est bien correct&nbsp;: l'espérance de la plus petite valeur
positive moins la plus grande valeur négative est bien le double de
l'espérance de deux valeurs consécutives, c'est le fameux paradoxe du
temps d'attente du bus).</p>
<p>Pour une <strong>loi binomiale</strong>, si le nombre <var>n</var>
d'essais n'est pas excessivement grand, le plus simple à programmer
est simplement l'algorithme naïf consistant à tirer <var>n</var>
variables de Bernoulli de paramètre <var>p</var> (indépendantes) et de
compter combien d'entre elles ont donné vrai.  Pour une <strong>loi
binomiale négative</strong>, si le nombre <var>r</var> d'échecs avant
arrêt est <em>entier</em> et n'est pas excessivement grand, de même,
le plus simple à programmer est simplement l'algorithme naïf
consistant à tirer <var>r</var> variables géométriques (indépendantes)
de probabilité de succès (enfin, ici c'est plutôt un échec, mais la
terminologie la plus courante parle de probabilité de <q>succès</q>)
1−<var>p</var> et de les sommer&nbsp;; en revanche, je ne sais pas générer
une loi binomiale négative avec <var>r</var> non entier sans faire
appel à des calculs de fonction&nbsp;Γ ou des systèmes de rejets, mais
pour <var>r</var> demi-entier, ce qui est un cas important, je vais en
redire un mot ci-dessous.</p>
<p>Bon, la plus important distribution continue est sans doute
la <strong>loi gaussienne</strong>.  Je rappelle que la somme
des <em>carrés</em> de <var>r</var> variable aléatoire gaussiennes
indépendantes de moyenne&nbsp;0 et de même espérance définit une loi du χ²
(chi-carré) avec <var>r</var> <q>degrés de liberté</q>, et que c'est
un cas particulier de la loi&nbsp;Γ (gamma), à savoir celui où le paramètre
de <q>forme</q> est demi-entier, précisément <var>r</var>/2&nbsp;; en
particulier, la somme des carrés de <em>deux</em> (<var>r</var>=2)
variables aléatoires gaussiennes indépendantes centrées de même
espérance est une variable aléatoire exponentielle&nbsp;: ou, si on
préfère, une gaussienne (isotrope, centrée) de
dimension&nbsp;<var>r</var>=2 (i.e., une variable aléatoire dans ℝ² dont
les deux coordonnées sont des gaussiennes réelles indépendantes
centrées de même espérance), si on la regarde en coordonnées polaires,
a une composante radiale qui est la racine carrée d'une variable
aléatoire exponentielle (et la composante angulaire est, bien sûr,
uniforme).</p>
<p>L'observation du paragraphe précédent donne naissance à
l'<strong>algorithme de Box-Muller pour tirer une variable de loi
gaussienne</strong>&nbsp;: tirer <var>U</var> et <var>V</var> deux
variables uniformes indépendantes sur [0;1], et alors
√(−2·log(<var>U</var>))·cos(2π<var>V</var>) et
√(−2·log(<var>U</var>))·sin(2π<var>V</var>) fournissent deux variables
gaussiennes standard (i.e., de moyenne&nbsp;0 et variance&nbsp;1) indépendantes.
Ici, −log(<var>U</var>) sert à tirer une variable exponentielle
d'espérance&nbsp;1, qu'on peut éventuellement corriger comme je l'ai
expliqué plus haut.</p>
<p>Un des intérêts de la loi gaussienne est, justement, qu'elle permet
de fabriquer des lois gaussiennes en toutes dimensions.  Ceci répond
notamment à la question fondamentale suivante&nbsp;: <strong>comment tirer
uniformément un point sur la sphère de
dimension&nbsp;<var>d</var>&nbsp;?</strong>  Le plus simple est de
tirer <var>d</var>+1 variables gaussiennes indépendantes centrées de
même espérance, ce qui constitue collectivement une variable
gaussienne centrée isotrope dans ℝ<sup><var>d</var>+1</sup>, et de
normaliser cette dernière, c'est-à-dire de tout diviser par la norme
(la racine carrée de la somme des carrés des variables tirées).
(Pour <var>d</var>=1, i.e., pour le cas d'un cercle, cela revient bien
sûr simplement à défaire ce qu'on a fait ci-dessus, et on peut
court-circuiter ce bazar en calculant simplement (cos(2π<var>V</var>),
sin(2π<var>V</var>)) avec <var>V</var> uniforme dans&nbsp;[0;1].)</p>
<p class="sidenote">(En rapport avec ce que je viens de dire, je
devrais
mentionner <a href="http://mathoverflow.net/questions/333041/the-square-modulus-of-coordinates-of-a-uniformly-chosen-point-in-complex-project">le
fait</a> notable suivant que si
(<var>z</var><sub>0</sub>:⋯:<var>z</var><sub><var>d</var></sub>) est
un point aléatoire uniforme de l'espace projectif complexe de
dimension (complexe) <var>d</var> pour la mesure associée à la
métrique de Fubini-Study, ce qui s'obtient simplement en prenant un
point de la sphère de dimension 2<var>d</var>+1, ses 2<var>d</var>+2
coordonnées réelles étant interprétées comme les <var>d</var>+1
composantes réelles et imaginaires des coordonnées complexes, alors
une fois normalisé par |<var>z</var><sub>0</sub>|² + ⋯ +
|<var>z</var><sub><var>d</var></sub>|² = 1, ce qui est déjà le cas si
on a fait comme je viens de le dire, le point
(|<var>z</var><sub>0</sub>|²,&nbsp;…,
|<var>z</var><sub><var>d</var></sub>|²) est uniformément réparti sur
le simplexe de dimension&nbsp;<var>d</var>.  Ce n'est qu'une reformulation
du fait que pour tirer un point de la (2<var>d</var>+1)-sphère selon
l'algorithme de Box-Muller, on tire un point du simplexe de
dimension&nbsp;<var>d</var> par normalisation de <var>d</var>+1 variables
aléatoires exponentielles dinépendantes et on tire <var>d</var>+1
phases uniformes indépendantes.  Mais ceci suggère la question
suivante&nbsp;: si on tire une matrice unitaire
(<var>d</var>+1)×(<var>d</var>+1) uniforme (selon la mesure de Haar de
U<sub><var>d</var>+1</sub>) et qu'on fabrique <var>d</var>+1 points du
simplexe de dimension <var>d</var> en considérant les carrés des
modules des différentes entrées de la matrice, quelle est la loi
jointe ainsi obtenue&nbsp;?)</p>
<p>Mais il faut noter qu'il n'y a pas que la sphère qu'on peut traiter
ainsi&nbsp;: pour <strong>tirer uniformément une matrice orthogonale de
taille <var>m</var>×<var>m</var></strong> (selon la mesure de Haar de
SO<sub><var>m</var></sub>, si on veut), le plus simple est de
tirer <var>m</var>² variables gaussiennes indépendantes centrées de
même espérance, qu'on considérera comme <var>m</var> vecteurs de
taille <var>m</var>, et de leur appliquer l'algorithme
de <a href="http://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">Gram-Schmidt</a>
pour les transformer en une base orthonormée (qui est uniformément
répartie sur toutes les bases orthonormées puisque, justement, toute
l'opération est invariante sous l'effet du groupe orthogonal).  Il me
semble vaguement qu'on peut faire quelque chose du même goût pour tous
les groupes de Lie réels compacts, mais je ne sais plus bien d'où je
tire cette idée.</p>
<p class="sidenote">(À titre d'exemple, pour tirer un
élément <var>g</var> de G₂, on commence par tirer
deux <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2015-02-03.2276.octonions.html#d.2015-02-03.2276" title="Les octonions sont-ils intéressants&nbsp;? (première partie)">octonions</a> imaginaires purs
gaussiens indépendants, qu'on orthonormalise, appelons
les <var>g</var>(<var>i</var>) et <var>g</var>(<var>j</var>), qui sont
donc orthogonaux et chacun uniforme sur la 6-sphère, on
pose <var>g</var>(<var>k</var>)
= <var>g</var>(<var>i</var>)·<var>g</var>(<var>j</var>) où il s'agit
ici de la multiplication octonionique, il est orthogonal
à <var>g</var>(<var>i</var>) et <var>g</var>(<var>j</var>), puis on
tire un troisième octonion imaginaire pur gaussien, indépendant des
tirages précédents,, dont on retire, comme par Gram-Schmidt, les
composantes
selon <var>g</var>(<var>i</var>), <var>g</var>(<var>j</var>)
et <var>g</var>(<var>k</var>), appelons <var>g</var>(<var>ℓ</var>) le
résultat&nbsp;: on pose alors <var>g</var>(<var>i</var>·<var>ℓ</var>)
= <var>g</var>(<var>i</var>)·<var>g</var>(<var>ℓ</var>) et de même
pour <var>g</var>(<var>j</var>·<var>ℓ</var>)
et <var>g</var>(<var>k</var>·<var>ℓ</var>)&nbsp;: alors
1, <var>g</var>(<var>i</var>), <var>g</var>(<var>j</var>), <var>g</var>(<var>k</var>), <var>g</var>(<var>ℓ</var>), <var>g</var>(<var>i</var>·<var>ℓ</var>), <var>g</var>(<var>j</var>·<var>ℓ</var>)
et <var>g</var>(<var>k</var>·<var>ℓ</var>) non seulement sont une base
orthonormée mais l'application <var>g</var> de passage de la base
1, <var>i</var>, <var>j</var>, <var>k</var>, <var>ℓ</var>, <var>i</var>·<var>ℓ</var>, <var>j</var>·<var>ℓ</var>, <var>k</var>·<var>ℓ</var>
à elle est uniformément distribuée selon la mesure de Haar de&nbsp;G₂.)</p>
<p>Bien sûr, pour <strong>tirer uniformément un point dans la boule
unité de dimension&nbsp;<var>d</var></strong>, on pourra tirer un point de
la sphère unité de dimension&nbsp;<var>d</var>−1 (on vient d'expliquer
comment) et le multiplier par la puissance (1/<var>d</var>)-ième d'une
variable uniforme sur&nbsp;[0;1].  La méthode de rejet (tirer un point de
[−1;1]<sup><var>d</var></sup> et recommencer jusqu'à ce qu'il soit
dans la boule) devient extrêmement inefficace quand <var>d</var> est
grand&nbsp;; notons cependant qu'elle ne l'est pas pour <var>d</var> petit,
et pour <var>d</var>=2 il est possiblement plus efficace de procéder
par rejet pour tirer un point du disque que comme je viens de dire,
voire, plus efficace pour tirer un point du <em>cercle</em> de tirer
d'abord un point du disque en procédant par rejet et ensuite de le
normaliser, en évitant ainsi d'avoir à évaluer des lignes
trigonométriques (ceci peut, justement, servir dans l'implémentation
de Box-Muller).</p>
<p>Le fait de savoir tirer une variable gaussienne permet de tirer des
variables de loi&nbsp;Γ de forme demi-entière, comme je l'ai déjà signalé
(puisque c'est une loi du&nbsp;χ²).  Il est notable, même si je ne sais pas
si ça peut servir à quelque chose, que quelque chose d'analogue peut
aussi servir dans le cas discret&nbsp;: ①&nbsp;pour tirer une
variable <var>k</var> entre 0&nbsp;et&nbsp;<var>n</var> (inclus) selon une loi
bêta-binomiale de paramètres <var>α</var>=<var>β</var>=½, par la
définition même de la loi bêta-binomiale, on peut tirer <var>p</var>
comme cos(2π<var>V</var>) avec <var>V</var> uniforme sur&nbsp;[0;1] (ceci
donne <var>p</var> suivant une loi bêta de
paramètres <var>α</var>=<var>β</var>=½) et ensuite <var>k</var> entre
0&nbsp;et&nbsp;<var>n</var> (inclus) selon une loi binomiale de
paramètre&nbsp;<var>p</var>&nbsp;; et ②&nbsp;pour tirer une variable distribuée selon
une loi de Pólya (binomiale négative) avec <var>r</var>=½ (ce que j'ai
envie d'appeler une loi <q>demi-géométrique</q>, parce que la somme de
deux variables indépendantes ainsi distribuées suit une loi
géométrique), on commence par tirer <var>n</var> selon une loi
géométrique (pour le même&nbsp;<var>p</var>), puis on tire <var>k</var>
selon une loi bêta-binomiale avec <var>α</var>=<var>β</var>=½ comme je
viens de le dire.
(Cf.&nbsp;<a href="https://math.stackexchange.com/questions/4151246/does-this-probability-distribution-have-a-standard-name">cette
question</a>.  Tout ça n'a rien de spécifique à&nbsp;½&nbsp;: c'est juste que ½
est le cas analogue discret du carré de la loi gaussienne, et aussi le
seul cas non entier que je sais traiter de façon élégante.  Soit dit
en passant, je suis preneur de toute situation «&nbsp;réelle&nbsp;» où la loi de
Pólya de paramètre <var>r</var>=½ ou bien la loi bêta-binomiale
avec <var>α</var>=<var>β</var>=½ joue un rôle particulier.)</p>
<p><strong>Ajout</strong> (<time>2021-06-03</time>)&nbsp;: On me propose en
commentaire le problème pratique suivant (tout à fait dans l'esprit de
ce billet de blog)&nbsp;: <strong>comment répartir un ensemble
de <var>n</var> personnes en deux «&nbsp;équipes&nbsp;», <var>A</var>
de <var>k</var> personnes et <var>B</var> de <var>n</var>−<var>k</var>
personnes, avec juste une pièce pour tirer à pile ou face&nbsp;?</strong>
Je propose la réponse suivante&nbsp;: chacun tire une pièce (disons qu'on
écrit ‘0’ pour pile et ‘1’ pour face)&nbsp;:</p>
<ul>

<li>s'il y a <var>k</var> personnes ayant tiré&nbsp;0
et <var>n</var>−<var>k</var> ayant tiré&nbsp;1, ce sera les
équipes <var>A</var> et <var>B</var> recherchés respectivement, et on
s'arrête là&nbsp;;</li>

<li>s'il y a <var>ℓ</var>&nbsp;&gt;&nbsp;<var>k</var> personnes ayant tiré&nbsp;0,
alors on met d'ores et déjà
les <var>n</var>−<var>ℓ</var>&nbsp;&lt;&nbsp;<var>n</var>−<var>k</var> ayant
tiré&nbsp;1 dans l'équipe&nbsp;<var>B</var>, et on répartit les <var>ℓ</var>
personnes ayant tiré&nbsp;0 en une équipe de&nbsp;<var>k</var>, qui sera
l'équipe&nbsp;<var>A</var>, et une équipe de <var>ℓ</var>−<var>k</var>,
qu'on ajoutera à l'équipe&nbsp;<var>B</var>, en recommençant
(récursivement) la procédure qu'on est en train de définir&nbsp;;</li>

<li>symétriquement, s'il y a <var>ℓ</var>&nbsp;&lt;&nbsp;<var>k</var> personnes
ayant tiré&nbsp;0, alors on les met d'ores et déjà dans
l'équipe&nbsp;<var>A</var>, et on répartit
les <var>n</var>−<var>ℓ</var>&nbsp;&gt;&nbsp;<var>n</var>−<var>k</var> ayant
tiré&nbsp;1 en une équipe de&nbsp;<var>k</var>−<var>ℓ</var>, qu'on ajoutera à
l'équipe&nbsp;<var>A</var>, et une équipe de <var>n</var>−<var>k</var>, qui
sera l'équipe&nbsp;<var>B</var>, en recommençant (récursivement) la
procédure qu'on est en train de définir.</li>

</ul>
<p>Autrement dit, tout le monde tire une première pièce, ce qui donne
deux groupes, 0&nbsp;et&nbsp;1, qu'on <em>aurait envie</em> d'identifier aux
équipes <var>A</var>&nbsp;et&nbsp;<var>B</var> mais ils n'ont pas forcément la
bonne taille&nbsp;: du coup, le groupe qui est moins nombreux que l'équipe
qu'on voulait constituer va directement dans l'équipe en question, et
le groupe est trop gros fait un nouveau tirage pour se répartir les
places restant à répartir selon le même procédé, jusqu'à ce que tout
le monde soit réparti.  Il revient au même de dire que chacun tire de
façon répétée des bits aléatoires mais qu'on fait juste les tirages
suffisants pour pouvoir envoyer les <var>k</var> premiers dans
l'équipe&nbsp;<var>A</var> et les <var>n</var>−<var>k</var> derniers dans
l'équipe&nbsp;<var>B</var>.</p>
<p>C'est un joli problème, et il me semble que la solution que je
propose est tout à fait facile à mener en pratique (elle est plus
compliquée à décrire qu'à appliquer), et ça ne m'étonnerait pas
qu'elle soit optimale en un certain sens (j'ai la flemme d'y
réfléchir&nbsp;; mais certainement pas par l'espérance du nombre total de
lancers puisque pour <var>k</var>=1 c'est beaucoup moins efficace,
selon cette métrique, que de générer un nombre uniforme entre
0&nbsp;et&nbsp;<var>n</var>−1 par la méthode que j'ai décrite plus haut).</p>
</div>
<footer class="entry-footer cleared"><p class="categories-list">Catégories&nbsp;: <a href="http://www.madore.org/~david/weblog/math.html" title="Mathématiques">math</a>(<a href="http://www.madore.org/~david/weblog/math.html#d.2021-06-02.2686">•</a>)</p>
<p class="talkback-link"><a href="http://www.madore.org/cgi-bin/comment.pl/showcomments?href=http%3a%2f%2fwww.madore.org%2f%7edavid%2fweblog%2f2021-06.html%23d.2021-06-02.2686">Commentaires</a><span id="d.2021-06-02.2686.numcomments"><!-- EMPTY --> (<strong>7</strong> @ 2021-06-04T08:57:06+0200)</span></p>
</footer>
</article><p><span>↑Entry #2686 [<a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-05-21.2685.points-and-lines.html#d.2021-05-21.2685" title="Configurations de points et droites&nbsp;: un petit projet mathématico-physico-artistique">older</a>|<a class="weblog-internal-link" href="#d.2021-06-02.2686" title="(Jump to top of entry)">※</a> <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-06-02.2686.random-generation.html#d.2021-06-02.2686" title="Trucs et astuces pour tirer au hasard diverses choses">permalink</a>|<del>newer</del>]</span> / <span xml:lang="fr" lang="fr">↑Entrée #2686 [<a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-05-21.2685.points-and-lines.html#d.2021-05-21.2685" title="Configurations de points et droites&nbsp;: un petit projet mathématico-physico-artistique">précédente</a>|<a class="weblog-internal-link" href="#d.2021-06-02.2686" title="(Retourner du début de l'entrée)">※</a> <a class="weblog-internal-link" href="http://www.madore.org/~david/weblog/d.2021-06-02.2686.random-generation.html#d.2021-06-02.2686" title="Trucs et astuces pour tirer au hasard diverses choses">permalien</a>|<del>suivante</del>]</span> ↑</p></div>
<script defer="defer" src="David%20Madore's%20WebLog%20Trucs%20et%20astuces%20pour%20tirer%20au%20hasard%20diverses%20choses_fichiers/x.js" type="text/javascript"></script>


<p class="sidenote">[<a href="http://www.madore.org/~david/weblog/weblog-index.html#index">Index of all
entries / <span xml:lang="fr" lang="fr">Index de toutes les entrées</span></a>
• <a href="http://www.madore.org/~david/weblog/">Latest entries / <span xml:lang="fr" lang="fr">Dernières
entrées</span></a> • <a href="http://www.madore.org/~david/weblog/weblog.rss" rel="alternate" title="RSS" type="application/rss+xml"><img alt="XML" src="David%20Madore's%20WebLog%20Trucs%20et%20astuces%20pour%20tirer%20au%20hasard%20diverses%20choses_fichiers/xml.gif" width="36" height="14"></a> (<abbr>RSS</abbr>&nbsp;1.0)
• <a href="http://www.madore.org/cgi-bin/comment.pl/lscomments">Recent
comments / <span xml:lang="fr" lang="fr">Commentaires récents</span></a>]</p>


<footer class="cleared"><hr>
<address class="author vcard"><a class="url fn" href="http://www.madore.org/~david/">David Madore</a> (<a class="despammed-address" href="mailto:david+www@madore.org"><code class="despammed-email">david+www@madore.org</code></a>|<a href="http://www.madore.org/~david/ego.html" rel="author">⁂</a>|<a href="https://twitter.com/gro_tsen" rel="author">Twitter</a>|<a href="http://www.facebook.com/grotsen" rel="author">Facebook</a>)</address>
</footer>


</body></html>