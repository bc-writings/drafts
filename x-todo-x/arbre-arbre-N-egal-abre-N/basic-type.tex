\begin{definition} \label{basic-type}
	Le type $arbre(\alpha)$ est défini comme suit où $\alpha$ est un type.

	\medskip

	\begin{center}
	\begin{prooftree}
    	\hypo{a : \alpha}
	    \infer1[\footnotesize\itshape (feuille)]{%
	    	Leaf(a) : arbre(\alpha)%
		}
	\end{prooftree}
	\quad\quad\quad
	\begin{prooftree}
    	\hypo{t_1 : arbre(\alpha)}
	    \hypo{t_2 : arbre(\alpha)}
    	\infer2[\footnotesize\itshape (noeud)]{%
	    	Node(t_1, t_2) : arbre(\alpha)%
		}
	\end{prooftree}
	\end{center}
\end{definition}


\begin{example} \label{exa-tree}
	A l'aide des règles précédentes, on peut définir l'arbre suivant de type $arbre(\NN)$ où nous utilisons les abréviations suivantes $N = Node$, $L = Leaf$ et $AN = arbre(\NN)$.
	
	\medskip
	\scriptsize
	
	\begin{center}
	\begin{prooftree}
	    \hypo{1 : \NN}
	    \infer1[\footnotesize\itshape (feuille)]{%
	    	l_1 = L(1) : AN%
		}
	    \hypo{2 : \NN}
	    \infer1[\footnotesize\itshape (feuille)]{%
	    	l_2 = L(2) : AN%
		}
	    \hypo{3 : \NN}
	    \infer1[\footnotesize\itshape (feuille)]{%
	    	l_3 = L(3) : AN%
		}
    	\infer2[\footnotesize\itshape (noeud)]{%
	    	n_{23} = N(l_2, l_3) : AN%
		}
    	\infer2[\footnotesize\itshape (noeud)]{%
	    	n_{123} = N(l_1, n_{23}) : AN%
		}
		\hypo{4 : \NN}
	    \infer1[\footnotesize\itshape (feuille)]{%
	    	l_4 = L(4) : AN%
		}
    	\infer2[\footnotesize\itshape (noeud)]{%
	    	N(n_{123}, l_4) : AN%
		}
	\end{prooftree}
	\end{center}
	
	\medskip
	\normalsize
	
	Dans la suite, on utilisera aussi une écriture fonctionnelle pour représenter un arbre.
	Pour notre exemple, ceci donne :
	\begin{pseudocode}
Node(
	Node(
		Leaf(1),
		Node(
			Leaf(2),
			Leaf(3)
		)
	),
	Leaf(4)
)
	\end{pseudocode}
	
	\medskip

	Avec cette représentation, le plus \emph{\og simple \fg} des arbres de type $arbre(\NN)$ est le suivant avec $k \in \NN$ quelconque.
	\begin{pseudocode}
Leaf(k)
	\end{pseudocode}
\end{example}
